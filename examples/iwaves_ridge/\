# -*- coding: utf-8 -*-
"""
Create a one cell quad grid

Created on Mon Nov 18 10:23:26 2013

@author: mrayson
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import operator

from soda.dataio.ugrid.ugridgen import cartesian_ugrid_gen
from soda.dataio.suntans.sunboundary import modifyBCmarker, Boundary, InitialCond
from soda.dataio.suntans.sunpy import Grid

PI = np.pi
GRAV=9.81

####################################################
# Inputs
beta = 7e-4
N = 0.01 # buoyancy freqncy
H = 1000.0
wave_period=12*3600.

phi0 = 0.1 # Internal wave amplitude

# Size of domain
ny = 1
nx = 100
nz = 20

suntanspath = 'rundata'

icfile = 'IWave_IC.nc'
bcfile = 'IWave_BC.nc'
####################################################

#######
# Compute wave parameters to get the domain size etc
k_z = PI / H        
omega = 2*PI/wave_period

k_x = k_z*omega / N

lambda_x = 2*PI / k_x

# Grid size
L = 2*lambda_x
dx = L/nx

W = dx

#####
# Create the grid
if not os.path.isdir(suntanspath):
    print 'Creating new directory: %s'%suntanspath
    os.mkdir(suntanspath)

xlims = [0,L]
ylims = [0,W]


# Create the grid
grd= cartesian_ugrid_gen(xlims, ylims, dx, suntanspath=suntanspath)

# Load the grid
grd = Grid(suntanspath)

grd.dv = H*np.ones_like(grd.xv)
grd.saveBathy('%s/depths.dat-voro'%suntanspath)

grd.dz = grd.calcVertSpace(nz, 1.0, H)
grd.saveVertspace('%s/vertspace.dat'%suntanspath)
grd.setDepth(grd.dz)

"""
# Create the boundary conditions


##########
# Modify the boundary markers and create the boundary condition file
##########
# This changes the edge types based on the polygons in the shapefile
#modifyBCmarker(suntanspath,bcpolygonfile)

# Modify the left and right edges and convert to type 2
hgrd = grd.convert2hybrid()

grd.mark[grd.mark>0]=2 # reset all edges to type-2

## convert edges +/- half a grid cell from the edge
#dx = hgrd.dg.max()
#xmin = hgrd.xe.min()+dx/4.0
#xmax = hgrd.xe.max()-dx/4.0
#
#indleft = operator.and_(hgrd.mark>0, hgrd.xe < xmin) # all boundaries
#indright = operator.and_(hgrd.mark>0, hgrd.xe > xmax) # all boundaries
#
## Free-surface boundaries
##grd.mark[indleft]=3
##grd.mark[indright]=3
#
## River boundaries
#grd.mark[indleft]=2
#grd.mark[indright]=2
##grd.edge_id[indleft]=1
##grd.edge_id[indright]=2
#
edgefile = suntanspath+'/edges.dat'
grd.saveEdges(edgefile)
print 'Updated markers written to: %s'%(edgefile)

#Load the boundary object from the grid
#   Note that this zeros all of the boundary arrays
bnd = Boundary(suntanspath,(starttime,endtime,dt))

bnd.setDepth(grd.dv)
#
## Try out a linear interpolation 
##y0 = bnd.ye.min()
##y1 = bnd.ye.max()
##du = 0.0
##dy = y1-y0
##Utst = (bnd.ye.ravel()-y0)/dy*du
#
## Normal components
#nx = hgrd.n1[grd.mark==2]
#ny = hgrd.n2[grd.mark==2]
#
#t = bnd.tsec-bnd.tsec[0]
#
##indleft = grd.xv[bnd.cellp] < x0
##indright = grd.xv[bnd.cellp]>x0
#if bnd.N3>0:
#    indleft = bnd.xv < x0
#    indright = bnd.xv>x0
#
## Height boundary
#for ii in range(bnd.N3):
#    hleft = h0 * np.sin(omega*t)
#    hright = h0 * np.sin(omega*t) # small lag
#    #hright = 0
#    if indleft[ii]:
#        bnd.h[:,ii] = hleft
#    else:
#        bnd.h[:,ii] = hright
#
#if bnd.N2>0:
#    indleft = bnd.xe < x0
#    indright = bnd.xe>x0
#
#
#
## Velocitty boundary
#for k in range(bnd.Nk):
#   for ii in range(bnd.N2):
#       
#       u = Umax * np.sin(omega*t)
#       h = A * np.sin(omega*t)
#       
#       if indleft[ii]:
#           bnd.boundary_u[:,k,ii] = u*nx[ii]*0
#           bnd.boundary_v[:,k,ii] = u*ny[ii]*0
#           bnd.boundary_h[:,ii] = h*0
#       elif indright[ii]:
#           bnd.boundary_u[:,k,ii] = u*nx[ii]
#           bnd.boundary_v[:,k,ii] = u*ny[ii]
#           bnd.boundary_h[:,ii] = h
#
#
## River flow boundary
#for k in range(bnd.Nk):
#   for ii in range(bnd.Nseg):
#
#       Q = hmax*W*u0 * np.sin(omega*t) # Flow rate
#       sfac = 1.
#       if ii == 1:
#           sfac = -1.
#       
#       bnd.boundary_Q[:,ii] = sfac*Q

# type-3 
#h = calc_fs(bnd.xv)

#bnd.h[:] = np.ones_like(bnd.h) * h



# Write the boundary file
bcfile = 'Seiche_BC.nc'
bnd.write2NC(suntanspath+'/'+bcfile)

#########
# Create the initial conditions file
#########
IC = InitialCond(suntanspath,starttime)

#seiche=Seiche(L,W,H,A)
#u,IC.h[:] = seiche(IC.xv,0)
IC.h[:] = 0

# Set T as a circle
x0 = L/2
y0 = W/2
R = W/10. # Radius

dist = np.sqrt( (IC.xv-x0)**2 + (IC.yv-y0)**2.)

IC.h[...,dist<=R] = Amid



# Write the initial condition file
IC.writeNC(suntanspath+'/'+icfile,dv=grd.dv)



#grd.plotmesh()
#plt.show()

"""
